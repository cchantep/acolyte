
<!DOCTYPE html>
<!--
 Generated by Apache Maven Doxia at 2014-09-27
 Rendered using Reflow Maven Skin 1.1.1 (http://andriusvelykis.github.io/reflow-maven-skin)
-->
<html  xml:lang="en" lang="en">

	<head>
		<meta charset="UTF-8" />
		<title>acolyte - Acolyte for ReactiveMongo</title>
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta name="description" content="" />
		<meta http-equiv="content-language" content="en" />

		<link href="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap.min.css" rel="stylesheet" />
		<link href="./css/docs.css" rel="stylesheet" />
		<link href="./css/reflow-skin.css" rel="stylesheet" />


		<link href="./css/lightbox.css" rel="stylesheet" />

		<link href="./css/site.css" rel="stylesheet" />
		<link href="./css/print.css" rel="stylesheet" media="print" />

		<!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
		<!--[if lt IE 9]>
			<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->


		
<link rel="stylesheet" type="text/css" href="css/pygments.min.css"/>
<link rel="stylesheet" type="text/css" href="css/responsive.css"/>
	</head>

	<body class="page-reactive-mongo project-acolyte" data-spy="scroll" data-offset="60" data-target="#toc-scroll-target">

		<div class="navbar navbar-fixed-top">
			<div class="navbar-inner">
				<div class="container">
					<a class="btn btn-navbar" data-toggle="collapse" data-target="#top-nav-collapse">
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</a>
					<div class="nav-collapse collapse" id="top-nav-collapse">
						<ul class="nav pull-right">
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">User guide <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="java.html" title="Java">Java</a></li>
									<li ><a href="scala.html" title="Scala">Scala</a></li>
									<li ><a href="faq.html" title="FAQ">FAQ</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Integration <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="integration.html" title="Guide">Guide</a></li>
									<li ><a href="integration.html#Play_Framework" title="Play Framework">Play Framework</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Subprojects <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="studio.html" title="Acolyte Studio">Acolyte Studio</a></li>
									<li ><a href="scalac-plugin.html" title="Scalac plugin">Scalac plugin</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Reference <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="jdbc-driver-javadoc/index.html" title="JDBC Javadoc">JDBC Javadoc</a></li>
									<li ><a href="jdbc-scaladoc/index.html" title="JDBC Scaladoc">JDBC Scaladoc</a></li>
									<li ><a href="jdbc-driver-javadoc/index.html" title="ReactiveMongo Scaladoc">ReactiveMongo Scaladoc</a></li>
									<li ><a href="build.html" title="Build">Build</a></li>
									<li ><a href="changelog.html" title="Changelog">Changelog</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Tutorial & Demo <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="http://tour.acolyte.eu.org" title="Interactive tour" class="externalLink">Interactive tour</a></li>
									<li ><a href="https://github.com/cchantep/acolyte/tree/10m-anorm-tutorial#acolyteanorm-10-minutes-tutorial" title="10m with Anorm" class="externalLink">10m with Anorm</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Support <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li ><a href="https://groups.google.com/forum/#!forum/acolyte-support" title="Mailing list" class="externalLink">Mailing list</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="#" class="dropdown-toggle" data-toggle="dropdown">Project Documentation <b class="caret"></b></a>
								<ul class="dropdown-menu">
									<li class="dropdown-submenu ">
										<a href="project-info.html" title="Project Information">Project Information</a>
										<ul class="dropdown-menu">
											<li ><a href="source-repository.html" title="Source Repository">Source Repository</a></li>
											<li ><a href="integration.html" title="Continuous Integration">Continuous Integration</a></li>
											<li ><a href="issue-tracking.html" title="Issue Tracking">Issue Tracking</a></li>
										</ul>
									</li>
								</ul>
							</li>
						</ul>
					</div><!--/.nav-collapse -->
				</div>
			</div>
		</div>

	<div class="container">

	<!-- Masthead
	================================================== -->

	<header>
		<div>
			<ul class="breadcrumb">
				<li class="projectVersion version-date">Version: 1.0.28</li>
				<li class="divider">|</li>
				<li class="publishDate version-date">Last Published: 2014-09-27</li>
			</ul>
		</div>
	</header>

	<div class="main-body">
	<div class="row">
		<div class="span12">
			<div class="body-content">
<div class="page-header">
 <h1>Acolyte for ReactiveMongo</h1>
</div> 
<p>Acolyte API for ReactiveMongo (0.10.0).</p> 
<div class="section"> 
 <h2 id="Motivation">Motivation</h2> 
 <p>Wherever in your code you use ReactiveMongo driver, you can pass Acolyte Mongo driver instead tests.</p> 
 <p>Then any connection created will be managed by your Acolyte (query &amp; writer) handlers.</p> 
</div> 
<div class="section"> 
 <h2 id="Usage">Usage</h2> 
 <ol style="list-style-type: decimal">
    <li>Configure connection handler according expected behaviour: which response to which query, which result for which write request.</li> 
    <li>Allow the persistence code to be given a <tt>MongoDriver</tt> according environment (e.g. test, dev, …, prod).</li> 
    <li>Provide this testing driver to persistence code during validation.</li> 
 </ol> 
 <div> 
  <pre>// 1. On one side configure the Mongo handler
import acolyte.reactivemongo.AcolyteDSL

val connectionHandler = AcolyteDSL handleQuery {
    // returns result according executed query
  } withWriteHandler {
    // returns result according executed write operation
  }

// 2. In Mongo persistence code, allowing (e.g. cake pattern) 
// to provide driver according environment.
import reactivemongo.api.MongoDriver

trait MongoPersistence {
  def driver: MongoDriver

  def foo = /* Function using driver, whatever is the way it's provided */
}

object ProdPersistence extends MongoPersistence {
  def driver = /* e.g. Resolve driver according configuration file */
}

// 3. Finally in unit tests
import scala.concurrent.Future
import acolyte.reactivemongo.AcolyteDSL

def isOk: Future[Boolean] = AcolyteDSL.withFlatDriver { d =&gt;
  val persistenceWithTestingDriver = new MongoPersistence {
    val driver: MongoDriver = d // provide testing driver
  }

  persistenceWithTestingDriver.foo
}
</pre> 
 </div> 
 <blockquote> 
  <p>When result Future is complete, Mongo resources initialized by Acolyte are released (driver and connections).</p> 
 </blockquote> 
 <p>For persistence code expecting driver as parameter, resolving testing driver is straightforward.</p> 
 <div> 
  <pre>import reactivemongo.api.MongoDriver
import acolyte.reactivemongo.AcolyteDSL.withDriver

val res: Future[String] = withDriver(yourConnectionHandler) { d =&gt;
  val driver: MongoDriver = d // configured with `yourConnectionHandler`

  val s: String = yourFunctionUsingMongo(driver)
  // ... dispatch query and write request as you want using pattern matching

  s
}
</pre> 
 </div> 
 <p>As in previous example, main API object is <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/reactive-mongo/src/main/scala/acolyte/reactivemongo/AcolyteDSL.scala">AcolyteDSL</a>.</p> 
 <p>Dependency can be added to SBT project with <tt>&quot;org.eu.acolyte&quot; %% &quot;reactive-mongo&quot; % &quot;1.0.27&quot;</tt>, or in a Maven one as following:</p> 
 <div> 
  <pre>
<span class="nt">&lt;dependency</span><span class="nt">&gt;</span>
  <span class="nt">&lt;groupId</span><span class="nt">&gt;</span>org.eu.acolyte<span class="nt">&lt;/groupId&gt;</span>
  <span class="nt">&lt;artifactId</span><span class="nt">&gt;</span>reactive-mongo<span class="nt">&lt;/artifactId&gt;</span>
  <span class="nt">&lt;version</span><span class="nt">&gt;</span>1.0.27<span class="nt">&lt;/version&gt;</span>
<span class="nt">&lt;/dependency&gt;</span>
</pre> 
 </div> 
 <p><i>See online <a class="externalLink" href="http://http://acolyte.eu.org/reactivemongo-scaladoc">API documentation</a></i>.</p> 
 <div class="section"> 
  <h3 id="Setup_driver">Setup driver</h3> 
  <p>Driver behaviour is configured using a connection handler, itself based on query and write handlers, managing respectively Mongo queries or write operations, and returning appropriate result.</p> 
  <p>You can start looking at empty/no-op connection handler. With driver configured in this way, there is no query or write handler. So as no response is provided whatever is the command performed, it will raise explicit error <tt>No response: ...</tt> for every request.</p> 
  <div> 
   <pre>import reactivemongo.api.MongoDriver
import acolyte.reactivemongo.AcolyteDSL

AcolyteDSL.withDriver(AcolyteDSL handle/*ConnectionHandler.empty*/) { d =&gt;
  val noOpDriver: MongoDriver = d
}
</pre> 
  </div> 
  <p>Acolyte provides several ways to initialize Mongo resources (driver, connection, DB and collection) your code could expect.</p> 
  <ul> 
   <li><tt>withDriver</tt> and <tt>withFlatDriver</tt>,</li> 
   <li><tt>withConnection</tt> and <tt>withFlatConnection</tt>,</li> 
   <li><tt>withDB</tt> and <tt>withFlatDB</tt>,</li> 
   <li><tt>withCollection</tt> and <tt>withFlatCollection</tt>,</li> 
   <li><tt>withQueryHandler</tt> and <tt>withFlatQueryHandler</tt>,</li> 
   <li><tt>withQueryResult</tt> and <tt>withFlatQueryResult</tt>,</li> 
   <li><tt>withWriteHandler</tt> and <tt>withFlatWriteHandler</tt>,</li> 
   <li><tt>withWriteResult</tt> and <tt>withFlatWriteResult</tt>.</li> 
  </ul> 
  <blockquote> 
   <p>Naming convention is <tt>withX(...) { a =&gt; b }</tt> to use with your Mongo function which doesn’t return <tt>Future</tt> result, and <tt>withFlatX(...) { a =&gt; b }</tt> when your Mongo function does return <tt>Future</tt> (so that result as <tt>Future[T]</tt> is flatten when returned, not having <tt>Future[Future[YourReturnType]]</tt> finally).</p> 
  </blockquote> 
  <div> 
   <pre>import reactivemongo.api.{ MongoConnection, MongoDriver }
import reactivemongo.bson.BSONDocument
import acolyte.reactivemongo.{ 
  AcolyteDSL, QueryResponse, PreparedResponse, Request, WriteOp 
}

// Simple cases
AcolyteDSL.withDriver(yourHandler) { d =&gt;
  yourFunctionWorkingWithDriver(d)
}

AcolyteDSL.withConnection(yourHandler) { c =&gt;
  yourFunctionWorkingWithConnection(c)
}

AcolyteDSL.withDB(yourHandler) { db =&gt;
  yourFunctionWorkingWithDB(db)
}

AcolyteDSL.withCollection(yourHandler, &quot;colName&quot;) { col =&gt;
  yourFunctionWorkingWithCol(col)
}

AcolyteDSL.withQueryHandler({ req: Request =&gt; 
  val resp: PreparedResponse = QueryResponse.empty // empty doc list
  resp
}) { d =&gt; yourFunctionWorkingWithDriver(d) }

AcolyteDSL.withQueryResult(queryResultForAll) { d =&gt;
  yourFunctionWorkingWithDriver(d)
}

AcolyteDSL.withWriteHandler({ cmd: (WriteOp, Request) =&gt; aResp }) { d =&gt;
  yourFunctionWorkingWithDriver(d)
}

AcolyteDSL.withWriteResult(writeResultForAll) { d =&gt;
  yourFunctionWorkingWithDriver(d)
}

// More complexe case
AcolyteDSL.withFlatDriver(yourHandler) { d =&gt; // expect a Future
  AcolyteDSL.withConnection(d) { c1 =&gt;
    if (yourFunction1WorkingWithConnection(c1))
      yourFunction2WorkingWithConnection(c1)
  }

  AcolyteDSL.withFlatConnection(d) { c2 =&gt; // expect a Future
    yourFunction3WorkingWithConnection(c2) // return a Future
  }

  AcolyteDSL.withFlatConnection(d) { c3 =&gt; // expect a Future
    AcolyteDSL.withFlatDB(c3) { db =&gt; // expect a Future
      AcolyteDSL.withFlatCollection(db, &quot;colName&quot;) { // expect Future
        yourFunction4WorkingWithDB(c3) // return a Future
      }
    }
  }
}
</pre> 
  </div> 
  <p>Many other combinations are possible: see complete <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/reactive-mongo/src/test/scala/acolyte/reactivemongo/DriverSpec.scala#L27">test cases</a>.</p> 
 </div> 
 <div class="section"> 
  <h3 id="Configure_driver_behaviour">Configure driver behaviour</h3> 
  <p>At this point we can focus on playing handlers. To handle Mongo query and to return the kind of result your code should work with, you can do as following.</p> 
  <div> 
   <pre>import reactivemongo.api.MongoDriver
import acolyte.reactivemongo.{ AcolyteDSL, Request }

AcolyteDSL.withDriver(
  AcolyteDSL handleQuery { req: Request =&gt; aResponse }) { d =&gt;
    val readOnlyDriver: MongoDriver = d
    // work with configured driver
  }

// Then when Mongo code is given this driver instead of production one ...
// (see DI or cake pattern) and resolve a BSON collection `col` by this way:

col.find(BSONDocument(&quot;anyQuery&quot; -&gt; 1).cursor[BSONDocument].toList().
  onComplete {
    case Success(res) =&gt; ??? // In case of response given by provided handler
    case Failure(err) =&gt; ??? // &quot;No response: &quot; if case not handled
  }
</pre> 
  </div> 
  <p>In the same way, write operations can be responded with appropriate result.</p> 
  <div> 
   <pre>import reactivemongo.api.MongoDriver
import acolyte.reactivemongo.{ AcolyteDSL, Request, WriteOp }

AcolyteDSL.withDriver(
  AcolyteDSL handleWrite { (op: WriteOp, req: Request) =&gt; aResponse }) { d =&gt;
    val writeOnlyDriver: MongoDriver = d
    // work with configured driver
  }

// Then when Mongo code is given this driver instead of production one ...
// (see DI or cake pattern) and resolve a BSON collection `col` by this way:

col.insert(BSONDocument(&quot;prop&quot; -&gt; &quot;value&quot;)).onComplete {
  case Success(res) =&gt; ??? // In case or response given by provided handler
  case Failure(err) =&gt; ??? // &quot;No response: &quot; if case not handled
}
</pre> 
  </div> 
  <p>Obviously connection handler can manage both queries and write operations:</p> 
  <div> 
   <pre>import acolyte.reactivemongo.{ AcolyteDSL, Request, WriteOp }

val completeHandler = 
  AcolyteDSL handleQuery { req: Request =&gt; 
    // First define query handling
    aQueryResponse
  } withWriteHandler { (op: WriteOp, req: Request) =&gt;
    // Then define write handling
    aWriteResponse
  }

AcolyteDSL.withDriver(completeHandler) { d =&gt;
  // work with configured driver
}
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="Request_patterns">Request patterns</h3> 
  <p>Pattern matching can be used in handler to dispatch result accordingly.</p> 
  <div> 
   <pre>import reactivemongo.bson.{ BSONInteger, BSONString }

import acolyte.reactivemongo.{
  CollectionName, QueryHandler, Request, Property, SimpleBody, &amp;
}

val queryHandler = QueryHandler { queryRequest =&gt;
  queryRequest match {
    case Request(&quot;a-mongo-db.a-col-name&quot;, _) =&gt; 
      // Any request on collection &quot;a-mongo-db.a-col-name&quot;
      resultA

    case Request(colNameOfAnyOther, _)  =&gt; resultB // Any request

    case Request(colName, SimpleBody((k1, v1) :: (k2, v2) :: Nil)) =&gt; 
      // Any request with exactly 2 BSON properties
      resultC

    case Request(&quot;db.col&quot;, SimpleBody((&quot;email&quot;, BSONString(v)) :: _)) =&gt;
      // Request on db.col starting with email string property
      resultD

    case Request(&quot;db.col&quot;, SimpleBody((&quot;name&quot;, BSONString(&quot;eman&quot;)) :: _)) =&gt;
      // Request on db.col starting with an &quot;name&quot; string property,
      // whose value is &quot;eman&quot;
      resultE

    case Request(_, SimpleBody((&quot;age&quot;: ValueDocument(
      (&quot;$gt&quot;, BSONInteger(minAge)) :: Nil)))) =&gt;
      // Request on any collection, with an &quot;age&quot; document as property,
      // itself with exactly one integer &quot;$gt&quot; property
      // e.g. `{ 'age': { '$gt', 10 } }`
      resultF

    case Request(&quot;db.col&quot;, SimpleBody(~(Property(&quot;email&quot;), BSONString(e)))) =&gt;
      // Request on db.col with an &quot;email&quot; string property,
      // anywhere in properties (possible with others which are ignored there)
      resultG

    case Request(&quot;db.col&quot;, SimpleBody(
      ~(Property(&quot;name&quot;), BSONString(&quot;eman&quot;)))) =&gt;
      // Request on db.col with an &quot;name&quot; string property with &quot;eman&quot; as value,
      // anywhere in properties (possibly with others which are ignored there).
      resultH

    case Request(colName, SimpleBody(
      ~(Property(&quot;age&quot;), BSONInteger(age)) &amp;
      ~(Property(&quot;email&quot;), BSONString(v)))) =&gt;
      // Request on any collection, with an &quot;age&quot; integer property
      // and an &quot;email&quot; string property, possibly not in this order.
      resultI

    case Request(colName, SimpleBody(
      ~(Property(&quot;age&quot;), ValueDocument(
        ~(Property(&quot;$gt&quot;), BSONInteger(minAge)))) &amp;
      ~(Property(&quot;email&quot;), BSONString(email)))) =&gt;
      // Request on any collection, with an &quot;age&quot; property with itself
      // a operator property &quot;$gt&quot; having an integer value, and an &quot;email&quot; 
      // property (at the same level as age), without order constraint.
      resultJ

    case CountRequest(colName, (&quot;email&quot;, &quot;em@il.net&quot;) :: Nil) =&gt;
      // Matching on count query
      resultK

    case CountRequest(_, (&quot;property&quot;, InClause(
      BSONString(&quot;A&quot;) :: BSONString(&quot;B&quot;) :: Nil)) :: Nil) =&gt;
      resultL // matches count with selector on 'property' using $in operator

    case Request(&quot;col1&quot;, SimpleBody((&quot;$in&quot;, ValueList(bsonA, bsonB)) :: Nil)) =&gt;
      // Matching BSONArray using with $in operator
      resultM

    case Request(_, RequestBody(List((&quot;sel&quot;, BSONString(&quot;hector&quot;))) ::
      List((&quot;updated&quot;, BSONString(&quot;property&quot;))) :: Nil)) ⇒ 
      // Matches a request with multiple document in body 
      // (e.g. update with selector)
      resultN

  }
}
</pre> 
  </div> 
  <p>Pattern matching using rich syntax <tt>~(..., ...)</tt> requires <a href="../scalac-plugin/readme.html">scalac plugin</a>. Without this plugin, such parameterized extractor need to be declared as stable identifier before <tt>match</tt> block:</p> 
  <div> 
   <pre>// With scalac plugin
request match {
  case Request(&quot;db.col&quot;, SimpleBody(
    ~(Property(&quot;email&quot;), BSONString(e)))) =&gt; result
  // ...
}

// Without
val EmailXtr = Property(&quot;email&quot;)
// has declare email extractor before, as stable identifier

request match {
  case Request(&quot;db.col&quot;, SimpleBody(~(EmailXtr, BSONString(e)))) =&gt; result
  // ...
}
</pre> 
  </div> 
  <p>In case of write operation, handler is given the write operator along with the request itself, so dispatch can be based on this information (and combine with pattern matching on request content).</p> 
  <div> 
   <pre>import acolyte.reactivemongo.{ WriteHandler, DeleteOp, InsertOp, UpdateOp }

val handler = WriteHandler { (op, wreq) =&gt;
  (op, wreq) match {
    case (DeleteOp, Request(&quot;a-mongo-db.a-col-name&quot;, _)) =&gt; resultDelete
    case (InsertOp, _) =&gt; resultInsert
    case (UpdateOp, _) =&gt; resultUpdate
  }
}
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="Result_creation_for_queries">Result creation for queries</h3> 
  <p>Mongo result to be returned by query handler, can be created as following:</p> 
  <div> 
   <pre>import reactivemongo.bson.BSONDocument
import reactivemongo.core.protocol.Response 
import acolyte.reactivemongo.{ QueryResponse, PreparedResponse }

val error1: PreparedResponse = QueryResponse.failed(&quot;Error #1&quot;)
val error2 = QueryResponse(&quot;Error #1&quot;) // equivalent

val success1 = QueryResponse(BSONDocument(&quot;name&quot; -&gt; &quot;singleResult&quot;))
val success2 = QueryResponse.successful(BSONDocument(&quot;name&quot; -&gt; &quot;singleResult&quot;))

val success3 = QueryResponse(Seq(
  BSONDocument(&quot;name&quot; -&gt; &quot;singleResult&quot;), BSONDocument(&quot;price&quot; -&gt; 1.2D)))

val success4 = QueryResponse.successful(
  BSONDocument(&quot;name&quot; -&gt; &quot;singleResult&quot;), BSONDocument(&quot;price&quot; -&gt; 1.2D))

val success5 = QueryResponse.empty // successful empty response
val success6 = QueryResponse(List.empty[BSONDocument]) // equivalent

val countResponse = QueryResponse.count(4) // response to Mongo Count
</pre> 
  </div> 
  <p>When a handler supports some query cases, but not other, it can return an undefined response, to let the chance other handlers would manage it.</p> 
  <div> 
   <pre>val undefined1 = QueryResponse(None)
val undefined2 = QueryResponse.undefined
</pre> 
  </div> 
 </div> 
 <div class="section"> 
  <h3 id="Result_creation_for_write_operation">Result creation for write operation</h3> 
  <p>Mongo result to be returned by write handler, can be created as following:</p> 
  <div> 
   <pre>import reactivemongo.core.protocol.Response 
import acolyte.reactivemongo.{ WriteResponse, PreparedResponse }

val error1: PreparedResponse = WriteResponse.failed(&quot;Error #1&quot;)
val error2 = WriteResponse(&quot;Error #1&quot;) // equivalent
val error3 = WriteResponse.failed(&quot;Error #2&quot;, 1/* code */)
val error4 = WriteResponse(&quot;Error #2&quot; -&gt; 1/* code */) // equivalent

val success1 = WriteResponse(1/* update count */ -&gt; true/* updatedExisting */)
val success2 = WriteResponse.successful(1, true) // equivalent
val success3 = WriteResponse() // = WriteResponse.successful(0, false)
</pre> 
  </div> 
  <p>When a handler supports some write cases, but not other, it can return an undefined response, to let the chance other handlers would manage it.</p> 
  <div> 
   <pre>val undefined1 = WriteResponse(None)
val undefined2 = WriteResponse.undefined
</pre> 
  </div> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Integration">Integration</h2> 
 <p>Acolyte for ReactiveMongo can be used with various test and persistence frameworks.</p> 
 <div class="section"> 
  <h3 id="Specs2">Specs2</h3> 
  <p>It can be used with <a class="externalLink" href="http://etorreborre.github.io/specs2/">specs2</a> to write executable specification for function accessing persistence.</p> 
  <div> 
   <pre>import reactivemongo.bson.BSONDocument
import acolyte.reactivemongo.QueryResponse

object MySpec extends org.specs2.mutable.Specification {
  &quot;Mongo persistence&quot; should {
    &quot;properly work with query result&quot; in {
      withQueryResult(QueryResponse(BSONDocument(???))) { driver =&gt;
        // code executing query with driver,
        // and parsing result as expected
      } aka &quot;result&quot; must beEqualTo(???).
        await(5) // as ReactiveMongo is async and returns Future
    }
  }

  // ...
}
</pre> 
  </div> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Build">Build</h2> 
 <p>This module can be built from these sources using SBT (0.12.2+), from top directory (Acolyte base directory): </p> 
 <div> 
  <pre># sbt 
&gt; project reactive-mongo
&gt; publish
</pre> 
 </div> 
</div> 
<div class="section"> 
 <h2 id="Test">Test</h2> 
 <div> 
  <pre># sbt 
&gt; project reactive-mongo
&gt; test
</pre> 
 </div> 
 <p><a class="externalLink" href="http://travis-ci.org/cchantep/acolyte"><img src="https://secure.travis-ci.org/cchantep/acolyte.png?branch=master" alt="Build Status" /></a></p> 
</div>
			</div>
		</div>
	</div>
	</div>

	</div><!-- /container -->

	<!-- Footer
	================================================== -->
	<footer class="well">
		<div class="container">
			<div class="row">
				<div class="span9 bottom-nav">
					<ul class="nav nav-list">
						<li class="nav-header">User guide</li>
						<li >
							<a href="java.html" title="Java">Java</a>
						</li>
						<li >
							<a href="scala.html" title="Scala">Scala</a>
						</li>
						<li >
							<a href="faq.html" title="FAQ">FAQ</a>
						</li>
						<li class="nav-header">Integration</li>
						<li >
							<a href="integration.html" title="Guide">Guide</a>
						</li>
						<li >
							<a href="integration.html#Play_Framework" title="Play Framework">Play Framework</a>
						</li>
						<li class="nav-header">Subprojects</li>
						<li >
							<a href="studio.html" title="Acolyte Studio">Acolyte Studio</a>
						</li>
						<li >
							<a href="scalac-plugin.html" title="Scalac plugin">Scalac plugin</a>
						</li>
						<li class="nav-header">Reference</li>
						<li >
							<a href="jdbc-driver-javadoc/index.html" title="JDBC Javadoc">JDBC Javadoc</a>
						</li>
						<li >
							<a href="jdbc-scaladoc/index.html" title="JDBC Scaladoc">JDBC Scaladoc</a>
						</li>
						<li >
							<a href="jdbc-driver-javadoc/index.html" title="ReactiveMongo Scaladoc">ReactiveMongo Scaladoc</a>
						</li>
						<li >
							<a href="build.html" title="Build">Build</a>
						</li>
						<li >
							<a href="changelog.html" title="Changelog">Changelog</a>
						</li>
						<li class="nav-header">Tutorial & Demo</li>
						<li >
							<a href="http://tour.acolyte.eu.org" title="Interactive tour" class="externalLink">Interactive tour</a>
						</li>
						<li >
							<a href="https://github.com/cchantep/acolyte/tree/10m-anorm-tutorial#acolyteanorm-10-minutes-tutorial" title="10m with Anorm" class="externalLink">10m with Anorm</a>
						</li>
						<li class="nav-header">Support</li>
						<li >
							<a href="https://groups.google.com/forum/#!forum/acolyte-support" title="Mailing list" class="externalLink">Mailing list</a>
						</li>
						<li class="nav-header">Project Documentation</li>
						<li >
							<a href="project-info.html" title="Project Information">Project Information <i class="icon-chevron-right"></i></a>
						</li>
					</ul>
				</div>
			</div>
		</div>
	</footer>

	<div class="container subfooter">
		<div class="row">
			<div class="span12">
				<p class="pull-right"><a href="#">Back to top</a></p>
				<p class="copyright">Copyright &copy;2014. All Rights Reserved.</p>
				<p><a href="http://github.com/andriusvelykis/reflow-maven-skin" title="Reflow Maven skin">Reflow Maven skin</a> by <a href="http://andrius.velykis.lt" target="_blank" title="Andrius Velykis">Andrius Velykis</a>.</p>
			</div>
		</div>
	</div>

	<!-- Le javascript
	================================================== -->
	<!-- Placed at the end of the document so the pages load faster -->
	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

	<script src="http://netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
	<script src="./js/lightbox.min.js"></script>
	<script src="./js/reflow-scroll.js"></script>

	<script src="./js/reflow-skin.js"></script>

	</body>
</html>
