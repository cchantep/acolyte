<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia at 2013-07-17
 | Rendered using Apache Maven Fluido Skin 1.3.0
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="Date-Revision-yyyymmdd" content="20130717" />
    <meta http-equiv="Content-Language" content="en" />
    <title>acolyte - </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.3.0.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />

      
    <script type="text/javascript" src="./js/apache-maven-fluido-1.3.0.min.js"></script>

    
            </head>
        <body class="topBarDisabled">
          
        
    
        <div class="container-fluid">
          <div id="banner">
        <div class="pull-left">
                                <div id="bannerLeft">
                <h2>Acolyte</h2>
                </div>
                      </div>
        <div class="pull-right">  </div>
        <div class="clear"><hr/></div>
      </div>

      <div id="breadcrumbs">
        <ul class="breadcrumb">
                
                    
                  <li id="publishDate">Last Published: 2013-07-17</li>
                  <li class="divider">|</li> <li id="projectVersion">Version: 1.0.5</li>
                      
                
                    
      
                                              
    <li class="pull-right">              <a href="http://github.com/cchantep/acolyte" class="externalLink" title="GitHub project">
        GitHub project</a>
  </li>

                        </ul>
      </div>

            
      <div class="row-fluid">
        <div id="leftColumn" class="span3">
          <div class="well sidebar-nav">
                
                    
                <ul class="nav nav-list">
                    <li class="nav-header">User guide</li>
                                
      <li>
    
                          <a href="./index.html#Java" title="Java">
          <i class="none"></i>
        Java</a>
            </li>
                  
      <li>
    
                          <a href="./index.html#Scala" title="Scala">
          <i class="none"></i>
        Scala</a>
            </li>
                  
      <li>
    
                          <a href="./index.html#Playframework" title="Playframework">
          <i class="none"></i>
        Playframework</a>
            </li>
                              <li class="nav-header">Reference</li>
                                
      <li>
    
                          <a href="./apidocs/index.html" title="Javadoc">
          <i class="none"></i>
        Javadoc</a>
            </li>
                              <li class="nav-header">Project Documentation</li>
                                                                                                                      
      <li>
    
                          <a href="project-info.html" title="Project Information">
          <i class="icon-chevron-right"></i>
        Project Information</a>
                  </li>
            </ul>
                
                    
                
          <hr class="divider" />

           <div id="poweredBy">
                            <div class="clear"></div>
                            <div class="clear"></div>
                            <div class="clear"></div>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                  </div>
          </div>
        </div>
        
                
        <div id="bodyColumn"  class="span9" >
                                  
            <h1>Acolyte</h1>
<p>Acolyte is a JDBC driver designed for cases like mockup, testing, or any case you would like to be able to handle JDBC query by hand (or maybe that&#x2019;s only Chmeee&#x2019;s son on the Ringworld).</p>
<p><a class="externalLink" href="http://travis-ci.org/cchantep/acolyte"><img src="https://secure.travis-ci.org/cchantep/acolyte.png?branch=master" alt="Build Status" /></a></p>
<p>This documentation can be read <a class="externalLink" href="http://cchantep.github.io/acolyte/">online</a>.</p>
<div class="section">
<h2>Requirements<a name="Requirements"></a></h2>

<ul>
  
<li>Java 1.6+</li>
</ul></div>
<div class="section">
<h2>Usage<a name="Usage"></a></h2>
<p>Acolyte driver behaves as any other JDBC driver, that&#x2019;s to say you can get a connection from, by using the well-known <tt>java.sql.DriverManager.getConnection(jdbcUrl)</tt> (and its variants).</p>
<p>JDBC URL should match <tt>jdbc:acolyte:anything-you-want?handler=id</tt> (see after for details about <tt>handler</tt> parameter).</p>
<p>Projects using Acolyte:</p>

<ul>
  
<li><a class="externalLink" href="https://github.com/cchantep/cielago-tracker">Cielago</a> (<a class="externalLink" href="https://github.com/cchantep/cielago-tracker/blob/master/test/models/DispatchReportSpec.scala">DispatchReportSpec</a>, <a class="externalLink" href="https://github.com/cchantep/cielago-tracker/blob/master/test/models/ListInfoSpec.scala">ListInfoSpec</a>, <a class="externalLink" href="https://github.com/cchantep/cielago-tracker/blob/master/test/controllers/MainSpec.scala">MainSpec</a>, &#x2026;)</li>
</ul>
<div class="section">
<h3>Java<a name="Java"></a></h3>
<p>Using Maven 2/3+, Acolyte dependency can be resolved as following from your POM:</p>

<div class="source">
<pre>&lt;!-- ... --&gt;

  &lt;repositories&gt;
    &lt;!-- ... --&gt;
    &lt;repository&gt;
      &lt;id&gt;applicius-snapshots&lt;/id&gt;
      &lt;name&gt;Applicius Maven2 Snapshots Repository&lt;/name&gt;
      &lt;url&gt;https://raw.github.com/applicius/mvn-repo/master/snapshots/&lt;/url&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;

  &lt;dependencies&gt;
    &lt;!-- ... --&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;acolyte&lt;/groupId&gt;
      &lt;artifactId&gt;acolyte-core&lt;/artifactId&gt;
      &lt;version&gt;VERSION&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

</pre></div>
<p>Then code could be:</p>

<div class="source">
<pre>import java.util.List;

import java.sql.DriverManager;
import java.sql.Connection;
import java.sql.Date;

import acolyte.ConnectionHandler;
import acolyte.StatementHandler;
import acolyte.CompositeHandler;
import acolyte.RowList3;
import acolyte.Result;

import acolyte.StatementHandler.Parameter;

import static acolyte.RowLists.rowList3;
import static acolyte.Rows.row3;

// ...

// Configure in anyway JDBC with following url,
// declaring handler registered with 'my-unique-id' will be used.
final String jdbcUrl = &quot;jdbc:acolyte:anything-you-want?handler=my-unique-id&quot;

// Prepare handler
StatementHandler handler = new CompositeHandler().
  withQueryDetection(&quot;^SELECT &quot;). // regex test from beginning
  withQueryDetection(&quot;EXEC that_proc&quot;). // second detection regex
  withUpdateHandler(new CompositeHandler.UpdateHandler() {
    // Handle execution of update statement (not query)
    public UpdateResult apply(String sql, List&lt;Parameter&gt; parameters) {
      // ...
      return UpdateResult.Nothing;
    }
  }).withQueryHandler(new CompositeHandler.QueryHandler () {
    public QueryResult apply(String sql, List&lt;Parameter&gt; parameters) {
      // ...

      // Prepare list of 2 rows
      // with 3 columns of types String, Float, Date
      RowList3&lt;String, Float, Date&gt; rows = 
        rowList3(String.class, Float.class, Date.class).
        withLabel(1, &quot;String&quot;).withLabel(3, &quot;Date&quot;). // Optional: set labels
        append(row3(&quot;str&quot;, 1.2f, new Date(1, 2, 3))).
        append(row3(&quot;val&quot;, 2.34f, new Date(4, 5, 6)));

      return rows.asResult();
    }
  });

// Register prepared handler with expected ID 'my-unique-id'
acolyte.Driver.register(&quot;my-unique-id&quot;, handler);

// then ...
Connection con = DriverManager.getConnection(jdbcUrl);

// ... Connection |con| is managed through |handler|
</pre></div>
<p>You can see more <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/core/src/test/java/usecase/JavaUseCases.java">use cases</a> whose expectations are visible in <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/core/src/test/scala/acolyte/AcolyteSpec.scala">specifications</a>.</p>
<p>If you just need/want to directly get connection from <tt>acolyte.Driver</tt>, without using JDBC driver registry, you can use Acolyte direct connection:</p>

<div class="source">
<pre>Connection con = new acolyte.Driver().connection(yourHandlerInstance);
</pre></div>
<div class="section">
<h4>Query result creation<a name="Query_result_creation"></a></h4>
<p>Acolyte provides <a class="externalLink" href="http://cchantep.github.io/acolyte/apidocs/acolyte/Row.html">Row</a> and <a class="externalLink" href="http://cchantep.github.io/acolyte/apidocs/acolyte/RowList.html">RowList</a> classes (and their sub-classes) to allow easy and typesafe creation of result.</p>
<p>Row lists can be built as following using <a class="externalLink" href="http://cchantep.github.io/acolyte/apidocs/acolyte/RowLists.html">RowLists factory</a>.</p>

<div class="source">
<pre>import acolyte.RowList1;
import acolyte.RowList3;

import static acolyte.RowLists.rowList1;
import static acolyte.RowLists.rowList3; 

// ...

RowList1&lt;String&gt; list1 = RowLists.rowList1(String.class);

RowList3&lt;Integer, Float, Character&gt; list2 = RowLists.
  rowList3(Integer.class, Float.class, Character.class)
</pre></div>
<p>In previous example, <tt>list1</tt> is a list of row with 1 column whose class is <tt>String</tt> (<tt>VARCHAR</tt> as for JDBC/SQL type). Considering <tt>list2</tt>, it is a list of row with 3 columns, whose classes are <tt>Integer</tt>, <tt>Float</tt> and <tt>Character</tt>.</p>
<p>Column names/labels can also be setup (column first index is 1):</p>

<div class="source">
<pre>// ...

list1 = list1.withLabel(1, &quot;first label&quot;);

list2 = list2.withLabel(2, &quot;first label&quot;).withLabel(3, &quot;third name&quot;);
</pre></div>
<p>Both column classes and names can be declared in bulk way, using <a class="externalLink" href="http://cchantep.github.io/acolyte/apidocs/acolyte/RowList.Column.html">definition class</a>:</p>

<div class="source">
<pre>import static acolyte.RowList.Column.defineCol;

// ...

RowList1&lt;String&gt; list1 = RowLists.
  rowList1(defineCol(String.class, &quot;first label&quot;));

RowList3&lt;Integer, Float, Character&gt; list2 = RowLists.
  rowList3(defineCol(Integer.class, &quot;1st&quot;), 
           defineCol(Float.class, &quot;2nd&quot;), 
           defineCol(Character.class, &quot;3rd&quot;));
</pre></div>
<p>Once you have declared your row list, and before turning it as result set, you can either add rows to it, or leave it empty.</p>

<div class="source">
<pre>import java.sql.ResultSet;

import static acolyte.Rows.row1;

// ...

// we have declared list1 and list2 (see previous example)

list1 = list1.append(row1(&quot;str&quot;));

ResultSet rs1 = list1.resultSet();
ResultSet rs2 = list2.resultSet();
</pre></div>
<p>From previous example, result set <tt>rs1</tt> will contain 1 row, whereas <tt>rs2</tt> is empty.</p>
<p>Take care to <tt>list1 = list1.append(row1(&quot;str&quot;));</tt>. As provided <tt>RowList</tt> classes are immutable, you should get updated instance from <tt>append</tt> to work on the list containing added row. This is more safe, and allow to rewrite previous example like:</p>

<div class="source">
<pre>ResultSet rs1 = list1.append(row1(&quot;str&quot;)).resultSet();
ResultSet rs2 = list2.resultSet();
</pre></div></div>
<div class="section">
<h4>SQL Warnings<a name="SQL_Warnings"></a></h4>
<p>Acolyte can also mock up SQL warnings, on update or query, so that <tt>java.sql.Statement.getWarnings()</tt> will returned expected instance.</p>

<div class="source">
<pre>import acolute.UpdateResult;
import acolyte.QueryResult;

// ...

// Update results to be returned from an acolyte.UpdateHandler
UpdateResult upNothingWarn = UpdateResult.Nothing.withWarning(&quot;Nothing&quot;);
UpdateResult up1ResWithWarn = UpdateResult.One.withWarning(&quot;Warning 1&quot;);
UpdateResult up10ResWithWarn = new UpdateResult(10).
  withWarning(&quot;updateCount = 10 with warning&quot;);

// Query result (wrapping row list) to be returned from acolyte.QueryHandler
QueryResult nilWithWarning = QueryResult.Nil.withWarning(&quot;Nil with warning&quot;);
QueryResult resWithWarning = aRowList.asResult().
  withWarning(&quot;Row list result with warning&quot;);
</pre></div></div></div>
<div class="section">
<h3>Scala<a name="Scala"></a></h3>
<p>Module <tt>acolyte-scala</tt> provide a Scala DSL to use more friendly Acolyte features.</p>
<p>Using SBT, Acolyte dependency can resolved as following:</p>

<div class="source">
<pre>resolvers += 
  &quot;Applicius Snapshots&quot; at &quot;https://raw.github.com/applicius/mvn-repo/master/snapshots/&quot;

libraryDependencies += &quot;acolyte&quot; %% &quot;acolyte-scala&quot; % &quot;VERSION&quot; % &quot;test&quot;
</pre></div>
<p>Then code could be:</p>

<div class="source">
<pre>import java.sql.{ Connection &#x21d2; SqlConnection, Date, DriverManager }
import acolyte.{ Driver &#x21d2; AcolyteDriver, Execution }
import acolyte.RowLists.{ rowList1, rowList3 }
import acolyte.Rows.row3
import Acolyte._ // import DSL

// ...

// Prepare handler
val handler: CompositeHandler = handleStatement.
  withQueryDetection(&quot;^SELECT &quot;). // regex test from beginning
  withQueryDetection(&quot;EXEC that_proc&quot;). // second detection regex
  withUpdateHandler({ e: Execution &#x21d2;
    if (e.sql.startsWith(&quot;DELETE &quot;)) {
      // Process deletion ...
      /* deleted = */ 2;
    } else {
      // ... Process ...
      /* count = */ 1;
    }
  }).withQueryHandler({ e: Execution &#x21d2;
    if (e.sql.startsWith(&quot;SELECT &quot;)) {
      // Empty resultset with 1 text column declared
      rowList1(String.class).asResult
    } else {
      // ... EXEC that_proc
      // (see previous withQueryDetection)

      // Prepare list of 2 rows
      // with 3 columns of types String, Float, Date
      rowList3(classOf[String], classOf[Float], classOf[Date]).
        withLabels( // Optional: set labels
          1 -&gt; &quot;String&quot;,
          3 -&gt; &quot;Date&quot;)
        :+ row3(&quot;str&quot;, 1.2f, new Date(1l))
        :+ row3(&quot;val&quot;, 2.34f, new Date(2l))).
        asResult

    }
  })

// Register prepared handler with expected ID 'my-handler-id'
AcolyteDriver.register(&quot;my-handler-id&quot;, handler)

// ... then connection is managed through |handler|
DriverManager.getConnection(jdbcUrl)
</pre></div>
<p>You can see detailed <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/scala/src/test/scala/acolyte/ScalaUseCases.scala">use cases</a> whose expectations are visible in <a class="externalLink" href="https://github.com/cchantep/acolyte/blob/master/scala/src/test/scala/acolyte/AcolyteSpec.scala">specifications</a>.</p>
<p>It&#x2019;s also possible to get directly get an Acolyte connection, without using JDBC driver registry:</p>

<div class="source">
<pre>import acolyte.Acolyte.connection

val con = connection(handler)
</pre></div>
<div class="section">
<h4>Query handler<a name="Query_handler"></a></h4>
<p>In Scala query handler, pattern matching can be use to easily describe result case:</p>

<div class="source">
<pre>import acolyte.{ Execution, DefinedParameter, ParameterVal }

handleStatement.withQueryDetection(&quot;^SELECT&quot;).
  withQueryHandler({ e: Execution =&gt; e match {
      case Execution(sql, DefinedParameter(&quot;str&quot;, _) :: Nil)
        if sql.startsWith(&quot;SELECT&quot;) =&gt;
        // result when sql starts with SQL 
        // and there is only 1 parameter with &quot;str&quot; value

      case Execution(_, ParameterVal(_) :: ParameterVal(2) :: _) =&gt;
        // result when there is at least 2 parameters for any sql
        // with the second having integer value 2
    }
  })
</pre></div></div></div>
<div class="section">
<h3>Playframework<a name="Playframework"></a></h3>
<p>Acolyte can be easily used with Play test helpers.</p>
<p>First step is to create a Play fake application:</p>

<div class="source">
<pre>import play.api.test.FakeApplication
import acolyte.{ StatementHandler }

def fakeApp(h: Option[StatementHandler] = None): FakeApplication =
  FakeApplication(additionalConfiguration = Map(
    &quot;application.secret&quot; -&gt; &quot;test&quot;,
    &quot;evolutionplugin&quot; -&gt; &quot;disabled&quot;) ++ h.fold(Map[String, String]())(
      handler &#x21d2; {
        val id = System.identityHashCode(this).toString
        acolyte.Driver.register(id, handler)

        Map(&quot;db.default.driver&quot; -&gt; &quot;acolyte.Driver&quot;,
          &quot;db.default.url&quot; -&gt; &quot;jdbc:acolyte:test?handler=%s&quot;.format(id))
      }))
</pre></div>
<p>Then Play/DB test can be performed as following:</p>

<div class="source">
<pre>lazy val handler = Some(handleStatement.
  withQueryDetection(&quot;^SELECT&quot;).withQueryHandler({ e: acolyte.Execution &#x21d2;
    // Any Acolyte result
  }))

Helpers.running(fakeApp(handler)) {
  DB withConnection { con &#x21d2;
    // Connection |con| will use provided |handler|
    // So any DB related test can be done there
  }
}
</pre></div>
<div class="section">
<h4>Result creation<a name="Result_creation"></a></h4>
<p>Row lists can be built in the following way:</p>

<div class="source">
<pre>import acolyte.{ RowList1, RowList3 }
import acolyte.RowLists.{ rowList1, rowList3 }

// ...

val list1: RowList1[String] = RowLists.rowList1(String.class)

val list2: RowList3[Int, Float, Char] = RowLists.
  rowList3(classOf[Int], classOf[Float], classOf[Char])
</pre></div>
<p>Column names/labels can also be setup (column first index is 1):</p>

<div class="source">
<pre>// ...

val list1up = list1.withLabel(1, &quot;first label&quot;)
val list2up = list2.withLabel(2, &quot;first label&quot;).withLabel(3, &quot;third name&quot;)
</pre></div>
<p>Both column classes and names can be declared in bulk way:</p>

<div class="source">
<pre>import acolyte.RowList.Column.defineCol

// ...

val list1: RowList1[String] = RowLists.rowList1(
  classOf[String] -&gt; &quot;first label&quot;)

val list2: RowList3[Int, Float, Char] = RowLists.rowList3(
  classOf[Int] -&gt; &quot;1st&quot;,
  classOf[Float] -&gt; &quot;2nd&quot;,
  classOf[Char] -&gt; &quot;3rd&quot;)
</pre></div>
<p>Once you have declared your row list, and before turning it as result set, you can either add rows to it, or leave it empty.</p>

<div class="source">
<pre>import java.sql.ResultSet

import acolyte.Rows.row1

// ...

val rs1: ResultSet = list1.append(row1(&quot;str&quot;)).resultSet()
val rs2: ResultSet = list2.resultSet()
</pre></div></div></div>
<div class="section">
<h3>Limitations<a name="Limitations"></a></h3>

<ul>
  
<li>Limited datatype conversions.</li>
  
<li>Binary datatype are not currently supported.</li>
  
<li><tt>ResultSet.RETURN_GENERATED_KEYS</tt> is not supported.</li>
  
<li>Pseudo-support for transaction.</li>
  
<li>Currency types.</li>
</ul></div></div>
<div class="section">
<h2>Build<a name="Build"></a></h2>
<p>Acolyte can be built from these sources using SBT (0.12.2+): <tt>sbt publish</tt></p></div>
<div class="section">
<h2>Documentation<a name="Documentation"></a></h2>
<p>Documentation is generated using Maven 3: <tt>mvn -f site.xml site</tt></p></div>
                  </div>
            </div>
          </div>

    <hr/>

    <footer>
            <div class="container-fluid">
              <div class="row span12">Copyright &copy;                   2013.
          All Rights Reserved.      
                    
      </div>

        
        
                </div>
    </footer>
  </body>
</html>
